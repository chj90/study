# 5장. 스트림 활용

스트림 API의 관리를 통해 내부적으로 다양한 최적화가 이루어질 수 있다  

## 5.1. 필터링

```java
List<Dish> vegetarianMenu = menu.stream()
                                .filter(Dish::isVegetarian)
                                .collect(toList());
```

- Predicate를 이용한 필터링: filter 함수

```java
List<Integer> numbers = Arrays.asList(1,2,1,3,3,2,4);
numbers.stream()
       .filter(i -> i % 2 == 0)
       .distinct()
       .forEach(System.out::println);

// 결과
2
4
```

- 고유 요소 필터링: distinct 함수

## 5.2. 스트림 슬라이싱

요소를 선택하거나 스킵하는 다양한 방법들이 있다

### TAKEWHILE 활용

```java
List<Dish> specialMenu = Arrays.asList(
    new Dish("seasonal fruit", true, 120, Dish.Type.OTHER),
    new Dish("prawns", false, 300, Dish.Type.FISH),
    new Dish("rice", true, 350, Dish.Type.OTHER),
    new Dish("chicken", false, 400, Dish.Type.MEAH),
    new Dish("french fries", true, 530, Dish.Type.OTHER));

List<Dish> filteredMenu = specialMenu.stream()
                           .filter(dish -> dish.getCalories() < 320)
                           .collect(toList());
```

칼로리가 320 미만인 음식들을 필터링 하는 코드는 다음과 같이 작성할 수 있다  
하지만, 컬렉션이 정렬되어 있다면 **takeWhile**을 사용해 성능을 향상 시킬 수 있다

```java
List<Dish> filteredMenu = specialMenu.stream()
                           .takeWhile(dish -> dish.getCalories() < 320)
                           .collect(toList());
// 선택 목록
seasonal fruit, prawns
```

### DROPWHILE 활용

반대로 320칼로리 보다 큰 요소를 추출하고 싶다면 **takeWhile**과 반대 동작을 하는 **dropWhile**을 사용

```java
List<Dish> filteredMenu = specialMenu.stream()
                           .dropWhile(dish -> dish.getCalories() < 320)
                           .collect(toList());
// 선택 목록
rice, chicken, french fries
```

### 스트림 축소

**limit(n)** 메서드를 사용해 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환

```java
List<Dish> filteredMenu = specialMenu.stream()
                           .filter(dish -> dish.getCalories() > 300)
                           .limit(3)
                           .collect(toList());
// 선택 목록
rice, chicken, french fries
```

### 요소 건너뛰기

**skip(n)** 메서드를 사용해 처음 n개 요소를 제외한 스트림을 반환

```java
List<Dish> filteredMenu = specialMenu.stream()
                           .filter(dish -> dish.getCalories() > 300)
                           .skip(2)
                           .collect(toList());
// 선택 목록
french fries
```

## 5.3. 매핑

특정 데이터를 선택하는 작업

### 스트림의 각 요소에 함수 적용하기

```java
List<String> dishNames = menu.stream()
                             .map(Dish::getName)
                             .collect(toList());
```

- 스트림의 요소를 변환하여 새로운 버전의 스트림을 제공

### 스트림 평면화

String 리스트를 고유문자 리스트로 반환하려면 어떻게 해야될까?

```java
// 대상 리스트
List<String> words = Arrays.asList("Hello", "World");

// 작업
...

// 예상결과
["H", "e", "l", "o", "W", "r", "d"]
```

```java
words.stream()
     .map(word -> word.split(""))
     .distinct()
     .collect(toList());
```

리스트의 단어를 각각의 문자로 매핑한 후 고유한 값으로 필터링하는 방법을 떠올릴 수 있다
하지만 위 방법은 아래와 같은 문제를 발생시킨다

- **map**은 Stream<String[]> 을 리턴
- 따라서 리스트끼리 고유값을 필터링하게 됨

```java
words.stream()
     .map(word -> word.split(""))
     .flatMap(Arrays.stream)
     .distinct()
     .collect(toList());
```

- Arrays::stream 함수는 리스트를 스트림으로 변환
- flatMap은 여러개의 스트림을 하나의 스트림으로 합침

## 5.4. 검색과 매칭

## 5.5. Reducing